\textbf{Descripci\'on} 

% \textbf{Direct-optimal basis computation by means of the fusion of Simplification rules, E. Rodr ́ıguez-Lorenzo et.al., Last review Discrete Appl. Math (2017)}

Una vez que hemos conseguido un algoritmo para el c\'alculo del cierre eficiente y optimizado, el siguiente paso para reducir el coste del c\'alculo del cierre es optimizar todo lo posible el sistema implicacional de entrada. Es aqu\'i donde entran en juego nuevos conceptos como es, por ejemplo, el de base directa \'optima.

K. Bertet \cite{BERTET20102155} propuso la llamada base directa \'optima como primera aproximaci\'on para reducir el coste del c\'alculo del cierre. Mientras que  K. Adaricheva \cite{Adaricheva} propuso la llamada D-Base como un subconjunto de la base directa \'optima. Esto supon\'ia un problema abierto: mejorar el c\'alculo de estas bases (o algo similar) para reducir el coste del c\'alculo del cierre en consecuencia.

La importancia del c\'alculo de bases directas de sistemas implicacionales ha sido remarcada por diferentes autores en \'areas diferentes ya que su uso es crucial en problemas donde se requiere el c\'alculo de gran cantidad de cierres. Por lo tanto, cuanto m\'as eficiente sea el c\'alculo de estas bases, mejor rendimiento tendr\'an los m\'etodos de resoluci\'on de esos problemas. 

A continuac\'on, se van a detallar algunos de estos conceptos.\\


\textbf{Base}

Un sistema implicacional \( \Sigma \) se dice que es:
\begin{itemize}
    \item Una base minimal cuando,  \( para \ todo \ A \to B \in \Sigma \ se \ tiene \ que \ \Sigma \setminus \{A \to B\} \not\equiv \Sigma\).

    \item Una base m\'inima cuando,  \( para \ todo \ \Sigma' \equiv \Sigma \ se \ tiene \ que \ |\Sigma| \leq |\Sigma'|\).

    \item Una base \'optima cuando,  \( para \ todo \ \Sigma' \equiv \Sigma \ se \ tiene \ que \ \|\Sigma\| \leq \|\Sigma'\| \\ donde \ \|\Sigma\| = 
    \sum_{\substack{A \to B \in \Sigma}} (|A|+|B|) \).
\end{itemize}
\newpage
\textbf{Directo}

Un sistema implicacional \( \Sigma \) se dice que es directo cuando, \( para \ todo \ X \subseteq S \ se \ tiene \ que \\ X^+_{\Sigma} =  X \cup \{ B | A \to B \in \Sigma \ para \ algun \ A \subseteq X \} \). Esto se traduce en que se puede calcular el cierre de un conjunto de atributos con una sola pasada y que ninguna de las implicaciones puede ser eliminada sin perder esta propiedad.

Por tanto, ya se est\'a en condiciones de conocer qu\'e es una base directa \'optima.\\

El teorema 2 de \cite{DO2} nos dice que:

Para cualquier sistema impicacional \(\Sigma\), existe un \'unica base directa \'optima \(\Sigma_{DO}\) tal que \(\Sigma \equiv \Sigma_{DO} \).\\

Como soluci\'on al c\'alculo de bases directas \'optimas se ha implementado el algoritmo desarrollado por  E. Rodr\'iguez-Lorenzo et al. \cite{DO2}, llamado [SLgetdo] en el cu\'al se aplican las reglas de L\'ogica de Simplificaciones \(\textbf{SL}_{FD}\).\\
\newpage
Aqu\'i se puede ver el pseudoc\'odigo de \(Simplify\), parte fundamental del algoritmo:

\IncMargin{1em}
\begin{algorithm}[H]
    \SetAlgoLined
    % \LinesNumbered
    \DontPrintSemicolon
    \SetKw{KwOr}{or}
    \KwIn{ 
        $\Sigma$, an implicational system on $S$
    }
    \KwOut{A simplified implicational system $ \Sigma_{s} $ that is equivalent to $\Sigma$}
    \Begin{
        \ $ \Sigma := \{ A \to B \setminus A \ | \ A  \to B \in \Sigma, \ B \not\subseteq A \}$\;
        \Repeat{$ \Sigma_{s} = \Sigma $} {
            \ $\Sigma_{S} = \Sigma$\;
            \ $\Sigma := \emptyset$\;
            \ForEach{$A \to B \in \Sigma_{s} $}{
                \ $\Gamma = \emptyset$\;
                \ForEach{$C \to D \in \Sigma $}{
                    \lIf{$C \subseteq A \subseteq (C \cup D) \ or \ A \subseteq C \subseteq (A \cup B)$}{
                        \ $A := A \cap C ; \ B := B \cap D$ 
                    }\Else{
                        \If{$A \subset C$}{
                            \If{$D \not\subseteq B$}{
                                \ $ add \ C \setminus B \to D \setminus B \ to \ \Gamma$ 
                            }   
                        }\Else{
                            \If{$C \subset A$}{
                                \ $ A := A \setminus D ; \ B := B \setminus D$ 
                            } 
                            \ $ add \ C \to D \ to \ \Gamma$
                        }
                    }
                }
                \lIf{$B = \emptyset$}{
                    \ $\Sigma := \Gamma$
                }\lElse{
                    \ $\Sigma := \Gamma \cup \{A \to B\}$
                }
            }
        }
        \Return $\Sigma_{s}$
    }%end beginre
    \caption{Simplify}\label{alg:4}
\end{algorithm}\DecMargin{1em}

% Add-sSimp

% \IncMargin{1em}
% \begin{algorithm}[H]
%     \SetAlgoLined
%     % \LinesNumbered
%     \DontPrintSemicolon
%     \SetKw{KwOr}{or}
%     \Begin{
%         \If{$A \not\subseteq C \ and \ B \cup C \neq \emptyset \neq D \setminus (A \cup B)$}{
%             \ $E := A \cup (C \setminus B)$ \;
%             \ $F := D \setminus (A \cup B)$ \;
%             \ForEach{$X \to Y \in \Sigma $}{
%                     \If{$X \subseteq E$}{
%                         \lIf{$C \subseteq Y$}{
%                             \Return $\emptyset$
%                         }\Else{
%                             \ $E := E \setminus Y$\;
%                             \ $F := F \setminus Y$\;
%                         } 
%                     }
%             } 
%             \Return $\{E \to F\}$
%         }\lElse{
%             \Return $\emptyset$
%         }
%     }%end beginre
%     \caption{Add-sSimp}\label{alg:5}
% \end{algorithm}\DecMargin{1em}

Y aqu\'i el pseudoc\'odigo en el que se basa la implementaci\'on del algoritmo:

\IncMargin{1em}
\begin{algorithm}[H]
    \SetKwFunction{Simplify}{Simplify}
    \SetKwFunction{Ssimp}{Add-sSimp}
    \SetAlgoLined
    % \LinesNumbered
    \DontPrintSemicolon
    \SetKw{KwOr}{or}
    \KwIn{ 
        $\Sigma$, an implicational system 
    }
    \KwOut{The equivalent direct-optimal implicational system $ \Sigma_{do} $}
    \Begin{
        \ $ \Sigma := \Simplify{$\Sigma$}$\;
        \Repeat{$ \Sigma_{do} = \Sigma $} {
            \ $\Sigma_{do} = \Sigma$\;
            \ $\Sigma := \emptyset$\;
            \ForEach{$A \to B \in \Sigma_{do} $}{
                \ $\Gamma = \emptyset$\;
                \ForEach{$C \to D \in \Sigma $}{
                    \lIf{$C \subseteq A \subseteq (C \cup D) \ or \ A \subseteq C \subseteq (A \cup B)$}{
                        \ $A := A \cap C ; \ B := B \cap D$ 
                    }\Else{
                        \lIf{$A \subseteq C$}{
                            \If{$D \not\subseteq B$}{
                                \ $ add \ C \setminus B \to D \setminus B \ to \ \Gamma$ 
                            }   
                        }\Else{
                            \If{$C \subseteq A$}{
                                \ $ A := A \setminus D ; \ B := B \setminus D$ 
                            } 
                            \ $\Gamma := \Gamma \cup \{C \to D \} \cup \Ssimp{$A \to B, \ C \to D, \ \Sigma$} \cup \Ssimp{$C \to D, \ A \to B, \ \Sigma$}$
                        }
                    }
                }
                \lIf{$B = \emptyset$}{
                    \ $\Sigma := \Gamma$
                }\lElse{
                    \ $\Sigma := \Gamma \cup \{A \to B\}$
                }
            }
        }
        \Return $\Sigma_{do}$
    }%end beginre
    \caption{SLgetdo algorithm}\label{alg:6}
\end{algorithm}\DecMargin{1em}

Una primera aproximaci\'on  fue el algoritmo desarrollado tambi\'en por E. Rodr\'iguez-Lorenzo et al. \cite{doSimp}, llamado doSimp tambi\'en basado en la L\'ogica de Simplificaciones, aplicando la simplificaci\'on Si-Eq y la composici\'on Co-Eq para simplificar el sistema implicacional, sSimp para completarlo y rSi-Eq y Co-Eq para optimizar el resultado final. Este primer algoritmo no se ha implementado en el proyecto ya que SLgetdo lo mejora, reduciendo el n\'umero de pasos a dos, as\'i como el tama\~no de las bases directas generadas hasta alcanzar la \'optima.
\newpage
\textbf{C\'odigo} 
\lstinputlisting{r_code/DO_IS.R}
\newpage
\lstinputlisting{r_code/simplify.R}
\newpage
\textbf{Ejemplo} 

% \textbf{[este ejemplo no me gusta, tiene vacios a la derecha.... y luego la base directa normalemente tiene mayor longitud. igual este ejemplo es de los que no va....¿¿??]}
A continuaci\'on, se muestra un ejemplo del c\'alculo de una base directa \'optima a partir del siguiente conjunto de implicaciones: 
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.75]{SLgetDO1}
    \caption{Ejemplo SLgetdo 1}
    \label{fig:SLgetDO1}
\end{figure} 

Aqu\'i se puede ver el resultado:
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.75]{SLgetDO2}
    \caption{Ejemplo SLgetdo 2}
    \label{fig:SLgetDO2}
\end{figure} 
Y, como era de esperar, el hecho de usar una base directa \'optima para el c\'alculo del cierre reduce consideradamente los tiempos de ejecuci\'on incluso en ejemplos tan peque\~nos como este, donde el c\'alculo es pr\'acticamente inmediato.\\

Se parte del conjunto de atributos \(\{c,f,g\}\).

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.75]{SLgetDO4}
    \caption{Comparativa del c\'alculo del cierre a partir de una base DO}
    \label{fig:SLgetDO4}
\end{figure}

Y como se puede ver, el resultado es el mismo:
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.75]{SLgetDO5}
    \caption{Comparativa del c\'alculo del cierre a partir de una base DO 2}
    \label{fig:SLgetDO5}
\end{figure}

Esta reducci\'on de tiempo se acent\'ua conforme crece el tama\~no del conjunto de implicaciones.

Si se tiene en cuenta que para resolver determinados problemas, el c\'alculo de multitud de cierres (del orden de millones) es parte fundamental \cite{Adaricheva}, el impacto de cualquier peque\~na mejora en el c\'alculo de cada uno de esos cierres, puede suponer una diferencia abismal. De ah\'i radica la importancia de este algoritmo.

% \textbf{Comparativa/Versiones} 