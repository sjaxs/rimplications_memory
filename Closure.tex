\subsubsection{Descripci\'on} 

% \textbf{The SLFD logic allows us to develop several automated deduction methods:
% Algorithm for redundancy elimination - CAEPIA 2003 (not complete)
% Algorithm for obtaining the closure of a set of attributes - CAEPIA 2005 - International Journal of Computer Mathematics 2011}

% \textbf{K. Bertet points to a good direction in [Bertet 2004] where Implicational Systems (IS) are highlighted as convenient tools to handle a closure system.
% K. Adaricheva [Adaricheva 2012] affirms that the search for the efficiency in the set closure computation is a major challenge.}

% \textbf{N. Caspard et B. Monjardet, \"The lattices of closure systems, closure operators, and implicational systems on a finite set: a survey\", Discrete Applied Mathematics, 2003, vol. 127, pp. 241-269.}
El campo de aplicaci\'on de los sistemas de cierre va desde \'areas te\'oricas, como el \'algebra o la geometr\'ia, a \'areas pr\'acticas como en inteligencia artificial y bases de datos.

Dado un conjunto de atributos \( M \) y un conjunto de implicaciones (o dependencias funcionales) \( \Sigma \) sobre \( M \) y sea \( X \subseteq M \), el cierre de \( X \) con respecto a \( \Sigma \), \( X^+_{\Sigma} \), es el subconjunto de \( M \) m\'as grande que cumple que \( \Sigma \vdash X \to X^+_{\Sigma} \).

El cierre es ampliamente usado en inteligencia artificial y bases de datos ya que es un punto clave en la resoluci\'on de muchos problemas: eliminaci\'on de restricciones redundantes, optimizaci\'on de consultas y el problema de la b\'usqueda de claves.

Por ello, se ha desarrollado un algoritmo de cierre, llamado \(\textbf{SL}_{FD}\)-Closure \cite{Mora2012a}, que en el peor de los casos, tiene la misma complejidad que los algoritmos de cierre lineales existentes.
El algoritmo aplica las reglas de L\'ogica de Simplicaciones \(\textbf{SL}_{FD}\) \cite{Cordero2002} y tiene la misma complejidad que los algoritmos de cierre cl\'asicos.

\IncMargin{1em}
\begin{algorithm}[h]
    \SetAlgoLined
    \LinesNumbered
    \DontPrintSemicolon
    \SetKw{KwOr}{or}
    \KwIn{$\Sigma$ a set of FDs; $X$ A set of attributes}
    \KwOut{$X^+$ the closure of $X$}
    \Begin{
        \ $X^+ = X$\;
        \Repeat{$X^+$ does not change} {
            \For{$A \to B \in \Sigma $}{
                \If{$A \subseteq X^+ and B \notin X^+$}{
                    \ $X^+ := X^+ \cup {B}$
                }
            }
        }
        \Return $X^+$
    }%end beginre
    \caption{apply.closure algorithm}\label{alg:2}
\end{algorithm}\DecMargin{1em}
\bigskip

De nuevo, se dispon\'ia de una primera implementaci\'on del algoritmo, la cual ha sido mejorada y optimizada con el fin de reducir el coste computacional del c\'alculo del cierre.

Si se compara esta versi\'on del algoritmo con las principales versiones que podemos encontrar a lo largo de la literatura, se puede ver que se consigue una mejora considerable \cite{Mora2012a}:

\begin{center}
    \begin{tabular}{c c}
        \hline
        M\'etodo & Tiempo Medio (ms) \\
        \hline
        Diederich Closure & 4.593,48 \\   
        Beeri Closure & 7.013,56 \\   
        Paredaens Closure & 5.863,35 \\  
        \(\textbf{SL}_{FD}\)-Closure & 1.262,41 \\  
    \end{tabular}
\end{center}
\newpage
\subsubsection{C\'odigo} 
\lstinputlisting{r_code/closure.R}
\subsubsection{Ejemplo} 
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{closure_ejemplo}
    \caption{Ejemplo apply.closure}
    \label{fig:closure_ejemplo}
\end{figure} 

Como se puede ver, dado un conjunto de atributos (x1) y un conjunto de implicaciones (mush), en este caso de 1000 implicaciones, se puede calcular el cierre de x1 respecto a mush en tan solo 33 segundos, tiempo bastante bueno teniendo en cuenta el tama\~no del conjunto de implicaciones.
\subsubsection{Comparativa/Versiones} 

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.75]{closure}
    \caption{Pruebas apply.closure}
    \label{fig:closure}
\end{figure} 

En la figura \ref{fig:closure} se puede ver una gr\'afica comparativa entre dos versiones distintas de esta funci\'on. La primera de ellas es la versi\'on de la que dispon\'ia el director de este TFG en el momento en que se empez\'o a desarrollar el mismo. La segunda es una versi\'on mejorada (como se puede ver m\'as arriba en el extracto de c\'odigo), que se realiz\'o como parte de este trabajo.

En este caso, dado que el coste computacional de esta funci\'on no es demasiado grande, las diferencias de rendimiento tampoco lo son si el n\'umero de implicaciones no es demasiado grande.

