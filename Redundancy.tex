\subsubsection{Descripci\'on} 

El objetivo de este algoritmo es servir de antesala a todos los dem\'as algoritmos con el fin de eliminar las reglas redundantes de un dataset de reglas antes de ser procesado por otro algoritmo. Esto conlleva una importante reducci\'on del coste computacional y temporal de la ejecuci\'on del resto de algoritmos.

El proceso de eliminar reglas redundantes se basa en aplicar la l\'ogica de implicaciones que ya hemos visto anteriormente. En este caso lo primero a realizar es la eliminaci\'on de reglas cuya parte derecha este vac\'ia y unir reglas que compartan parte izquierda (consecuente).

Lo siguiente consiste en aplicar la simplificaci\'on y la rsimplificaci\'on de reglas de forma repetida hasta que se alcance un punto fijo, esto es, no se puedan simplificar m\'as reglas.

El \'ultimo paso consiste en aplicar la transitividad generalizada, lo cu\'al nos permite eliminar reglas que puedan ser inferidas transitivamente a partir de otras.

Para ilustrar la importancia de este algoritmo vamos a ver algunos ejemplos donde se pueda apreciar el n\'umero de reglas que se eliminan y su importancia en la reducci\'on de coste computacional.

\subsubsection{Ejemplo}

Para ilustrar este ejemplo, vamos a partir de un conjunto de 200 reglas generadas con el algoritmo apriori a partir del dataset Mushroom incluido en el paquete arules.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{red_1}
    \caption{Reglas Mushroom}
    \label{fig:red_1}
\end{figure} 

A este conjunto le aplicamos el algoritmo y vemos cuantas reglas no redundantes se obtienen a partir del conjunto inicial.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{red_2}
    \caption{Reglas Mushroom no redundates}
    \label{fig:red_2}
\end{figure} 

Como podemos ver, de 200 reglas iniciales, se consigue reducir a 38 reglas, lo que supone una reducci\'on nada despreciable del 81 \% .

Si probamos a utilizar estos conjuntos de reglas con otros algoritmos podremos ver la reducci\'on del coste computacional. En este caso vamos a probar el algoritmo que calcula el cerrado de un conjunto de reglas a partir de un conjunto de atributos.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{red_3}
    \caption{Calculo del cierre}
    \label{fig:red_3}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{red_4}
    \caption{Tiempos de calculo del cierre}
    \label{fig:red_4}
\end{figure}

Aunque, en este caso pueda parecer que la diferencia de tiempo es poca, se debe a que el algoritmo de calculo de cierre es un algoritmo bastante r\'apido. En esta caso se reduce el tiempo necesario para el calculo del cierre en casi un 70 \%.

\newpage
\subsubsection{C\'odigo} 
\lstinputlisting{r_code/redundancy.R}
\newpage
 
\subsubsection{Comparativa/Versiones} 
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.75]{Redundancy}
    \caption{Pruebas remove.redundancy}
    \label{fig:redundancy}
\end{figure} 

En la figura \ref{fig:redundancy} podemos ver una grafica comparativa entre dos versiones distintas de esta funcion. La primera de ellas es la version de la que disponia el director de este TFG en el momento en que se empezo a desarrollar el mismo. La segunda es una version mejorada (como se puede ver mas arriba en el extracto de codigo), que se realizo como parte de este trabajo.