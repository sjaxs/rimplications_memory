%Estructura de datos
\section{Estructura de datos}

Un primer objetivo, esencial para este TFG conjunto, era la elecci\'on 
de una estructura de datos eficiente para la representaci\'on en R de los 
sistemas de implicaciones.

Si se quiere que los algoritmos a desarrollar sean eficientes, una de las cosas m\'as 
importantes a decidir es la estructura de datos. Dada la importancia de este paso, se realiz\'o 
un estudio te\'orico-pr\'actico de varias posibilidades que ofrec\'ia el lenguaje R. Se destaca 
el esfuerzo y tiempo dedicado en esta etapa, aunque debido a las limitaciones de espacio no se 
muestran los alternativas a la estructura elegida para almacenar implicaciones.

Por ello, en la gran mayor\'ia de algoritmos que se van a realizar 
en este TFG, se va a utilizar la estructura de datos rules, formada por varios 
elementos con la estructura ItemMatrix como elemento fundamental, perteneciente al paquete 
arules.

Rules es la estructura de datos para almacenar las implicaciones del paquete arules dise\~nado y mantenido 
por M. Hashler. Cabe destacar, que fue necesario el estudio de todas las clases, m\'etodos del tipo S3 y S4 para 
poder usar de forma eficiente la estructura de datos rules.
\\

La estructura de datos rules est\'a formada por cuatro slots, es decir, por 
cuatro campos de informaci\'on diferentes:

\begin{itemize}
    \item \textbf{lhs:}
    Lista de objetos de la clase ItemMatrix, en la cual se profundizar\'a m\'as 
    adelante. En este slot encontraremos todas las partes izquierdas, o antecedentes, de las 
    implicaciones, cada una de ellas con varios slots m\'as, debido a que son de la 
    clase ItemMatrix. 

    \item \textbf{rhs:}
    De nuevo, es una lista de objetos de la clase ItemMatrix. S\'olo que en este 
    slot encontraremos las partes derechas de las implicaciones, es decir, los consecuentes.

    \item \textbf{quality:}
    Objeto de la clase data.frame. En \'el se puede consultar la confianza de cada 
    una de las reglas. Este slot es usado en data mining almacenando en \'el el 
    soporte y la confianza de las reglas. Aunque en este caso, vamos a considerar 
    solo reglas de asociaci\'on con confianza 1, en una futura extensi\'on de los 
    algoritmos desarrollados a lo largo de este proyecto, tambi\'en se manejar\'an reglas de 
    asociaci\'on, por lo que el slot quality jugar\'a un papel bastante importante.

    \item \textbf{info:}
    Lista con varios campos con informaci\'on del conjunto de implicaciones. Se puede 
    encontrar el nombre del dataset al que pertenecen, el n\'umero de transacciones, 
    el soporte o la confianza.

\end{itemize}


Como se ha visto en los apartados lhs y rhs, ambos est\'an formados por una lista de 
ItemMatrix, por lo que a continuaci\'on se va a detallar dicha clase, con todos sus slots.

La clase ItemMatrix es la estructura b\'asica para las transacciones, los 
conjuntos de elementos y las reglas.
La clase contiene una representaci\'on de una matriz dispersa de elementos 
y las etiquetas correspondientes a dichos elementos.

Los conjuntos de elementos se representan como matrices binarias dispersas. 
Si se trabaja con varios ItemMatrix al mismo tiempo, la codificaci\'on 
en los diferentes ItemMatrix es importante, ya que ambos elementos deben tener 
las mismas etiquetas para poder trabajar con ellos.

Cada ItemMatrix tiene la siguiente informaci\'on:
\begin{itemize}

    \item \textbf{data:}
    Objeto de la clase ngCMatrix que almacena las ocurrencias de elementos en 
    representaci\'on dispersa. Hay que tener en cuenta que ngCMatrix est\'a orientado 
    a columnas, e ItemMatrix a filas, y cada una de dichas filas representa un elemento.
    Como resultado, el ngCMatrix en este caso siempre ser\'a una versi\'on traspuesta 
    de la matriz de incidencia binaria en ItemMatrix.

    \item \textbf{itemInfo:}
    Es un data.frame que contiene vectores de longitud igual al n\'umero de elementos que 
    hay en el conjunto. Si no est\'a vac\'io, el primer elemento del data.frame debe tener 
    \textit{labels} como nombre, y contener un vector de car\'acteres con las etiquetas de los 
    elementos utilizados para representar dicho elemento. Adem\'as de estas etiquetas, el 
    data.frame puede contener vectores con nombre arbitrario, para representar, por ejemplo, 
    nombres de variables y valores que se usaron para crear los elementos binarios o 
    informaci\'on de categor\'ia jer\'arquica asociada con cada etiqueta.


    \item \textbf{itemsetInfo:}
    Es un data.frame que puede contener informaci\'on adicional para las filas en la matriz.

\end{itemize}


Veamos un ejemplo:

Si tenemos las siguientes implicaciones guardadas en la variable \textit{rules}:
\begin{verbatim}
    a -> b
    c -> a
    d -> e
\end{verbatim}


Si ejecutamos el comando \textbf{rules@lhs@data} vamos a obtener una matriz dispersa de la clase 
ngCMatrix en la que podremos observar qu\'e elementos se encuentran en la parte izquierda de 
nuestras implicaciones, es decir, en los antecedentes.

\begin{verbatim}
    5 x 3 sparse Matrix of class "ngCMatrix"
    [1,] | . .
    [2,] . . .
    [3,] . | .
    [4,] . . |
    [5,] . . .
\end{verbatim}

Es decir, las filas son los diferentes elementos que tenemos en todas las reglas, y las 
columnas son cada una de las implicaciones.

\clearpage

Al ejecutar \textbf{rules@lhs@itemInfo}, vamos a obtener el nombre de cada uno de los elementos que 
tiene nuestro conjunto de implicaciones. 

\begin{verbatim}
    labels
    1      a
    2      b
    3      c
    4      d
    5      e
\end{verbatim}


Por \'ultimo, si ejecutamos \textbf{rules@lhs@itemsetInfo}, se obtiene el n\'umero de columnas y filas 
que tiene el data.frame de info. 
Como en este caso no tiene ninguna informaci\'on, obtenemos lo siguiente:
\begin{verbatim}
    data frame with 0 columns and 0 rows
\end{verbatim}


Esta estructura de datos, es bastante \'util para trabajar con conjuntos, ya que se pueden 
realizar todas las operaciones de forma eficiente, como por ejemplo, uni\'on o intersecci\'on.
Adem\'as, si se quiere obtener un conjunto de implicaciones de un dataset, al usar la funci\'on 
apriori del paquete arules, nos devolver\'a un conjunto en un ItemMatrix, por lo que nos va a 
resultar m\'as sencillo trabajar con este tipo de estructura, ya que es la m\'as 
extendida a nivel general. Por lo que a la hora de publicar el paquete de funciones, cuando otras 
personas quieran usar nuestros algoritmos, lo podr\'an realizar con facilidad, ya que se ajusta 
a como se trabaja en la actualidad en an\'alisis de datos.

As\'i que, debido a la estructura de esta clase, la facilidad de uso, y la adecuaci\'on a 
los datos que se van a utilizar a lo largo de este TFG, se ha elegido la estructura rules, compuesta de ItemMatrix 
como la principal a usar.

